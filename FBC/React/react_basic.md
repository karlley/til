# React LEARN REACT

https://ja.react.dev/learn/describing-the-ui

## UIの記述

- Reactコンポーネント: マークアップ用のJavaScript関数
- `export default`: メイン関数に設定する
- JSX内の`{}` の中にはJavaScriptを書ける
- リストのレンダリングには各要素の`key` を指定する必要がある
- JavaScript関数定義時の注意点
  - 呼び出される前に存在していたオブジェクトや変数を変更しない
  - 同じ入力を与えると、常に同じ結果を返す
- モジュール依存関係ツリー
  - 階層構造のコンポーネントをツリー上に表現したもの
  - propsを使った値の流れを理解するのに役立つ

## 初めてのコンポーネント

- コンポーネント: 再利用可能なUI要素
- オープンソースのReactコンポーネント
  - [Chakra UI](https://www.chakra-ui.com/)
  - [Material UI: React components that implement Material Design](https://mui.com/material-ui/)
- Reactコンポーネント: マークアップを添えることができるJavaScript 関数
- ReactコンポーネントのJavaScript関数名は大文字から始める必要がある
- コンポーネントの定義のネストは不可
  - 全てのコンポーネントをトップレベルで定義する必要がある

## コンポーネントのインポートとエクスポート

- コンポーネントを再利用する
  - 再利用される側: デフォルト or 名前付きエクスポート
  - 再利用する側: インポート
- インポート時の`.js` は省略できる
  - `import Gallery from './Gallery';`
  - 基本的には省略しないほうが良さそう
- デフォルトクスポート、名前付きエクスポート
  - [JavaScriptのデフォルトエクスポート、名前付きエクスポート \- karlley](https://scrapbox.io/karlley/React%E3%81%AE%E3%83%87%E3%83%95%E3%82%A9%E3%83%AB%E3%83%88%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88%E3%80%81%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88%E3%81%AE%E4%BD%BF%E3%81%84%E5%88%86%E3%81%91)
  - `export default () => {}` のような無名のコンポーネントは定義しない

## JSXでマークアップを記述する

- Reactでマークアップとロジックを1つのコンポーネントに記述するようになった理由
  - JavaScriptのロジックにマークアップを決めるようになったから
- JSX
  - 言語の拡張
  - Reactとは別のモノ
  - JSX/Reactのどちらか片方のみ独立して使うことも可能
- JSXのルール
  - 単一のルート要素を返す
    - `<div></div>` or `<></>` で囲む(フラグメント)
  - 全てのタグを`/` で閉じる
  - 属性はキャメルケースで記述
- HTMLをコンバータでJSXに変換できる
  - [HTML to JSX](https://transform.tools/html-to-jsx)

## JSX に波括弧で JavaScript を含める

- JSX内の`{}` 内にはJavaScriptが使える
- `{}` の間違った使い方
  - HTMLのタグ名に使う: `<{tag}></{tag}>`
  - 属性値を`""` で囲む: `src="{url}"`
- `{}` の中でオブジェクトを渡すことも可能
  - `{{name: "Alice", age: 18}}`

## コンポーネントに props を渡す

- propsの特徴
  - 親から子に渡す情報
  - オブジェクト、配列等何でも渡せる
  - JSXに渡す情報
  - 子コンポーネントに渡す調整用のツマミのイメージ
  - 子コンポーネント唯一の引数

- propsの使い方
  - 子コンポーネントでの受取は`({name, age})` のように`{}` で分割代入する
  - デフォルト値を設定できる
    - `function Avatar({name, age = 20}) {}`
  - スプレッド構文でpropsを受け取ることも可能
    - `<Avatar ({...props}) />`

- children
  - JSX内でコンポーネントをネストさせた場合に親コンポーネントが受け取るpropsの中身
    - ネスト内の子にそのまま`children` が渡る
    - ネスト内の親コンポーネントは子コンポーネントを柔軟に変更できる

- propsは状態
  - 任意の時点でのコンポーネントのデータを反映するもの
  - propsは書き換えるのはNG
    - propsを変更する場合は親コンポーネントからstateを再セットする

## 条件付きレンダー

- 条件分岐でコンポーネントを描画させたくない場合は`null` を返すことで可能だが推奨されない
  - `{cont ? <p>content</p> : null}` NG
  - `{count && <p>content</p>}` OK
- `&&`の左を書く場合は真偽値に変換して条件分岐を行う
  - `count && <p>content</p>` NG(countが0の場合は`0` が表示される)
  - `count > 0 && <p>content</p>` OK

## リストのレンダー

- アロー関数の`return` の省略
  - `{}` が無い場合は省略可
    - `items.map(item => <p>content</p>);`
  - `{}` が有る場合は省略不可
    - `items.map(item => { return <p>content</p> });`

- リストの子要素にはユニークなkeyを指定する必要がある
  - ソート、削除時に正しく子要素を認識できる

- `<Fragment>`: 明示的に`<></>` を記述できる
  - key等を指定できる

- key 
  - DBのid、インクリメントした値などユニークな値を使用する
  - 値を変更するのはNG(idの意味が無くなる)
  - 子コンポーネントでidを受け取る場合は別propsとして渡す必要がある
    - `<Profile key={id} userId={id} />`

## コンポーネントを純粋に保つ

- 純関数
  - 計算だけを行い、他には何もしない関数
  - 副作用が無い
  - 呼び出し前のオブジェクト、変数を変更しない

- Reactのコンポーネントは純関数でなければならない
  - 何度呼び出しても結果が変わらない
  - 呼び出し順を意識しなくて良い
  - render中に外部から渡ってきた値の変更はNG

- アニメーション等の描画に関する副作用を起こしたい場合はイベントハンドラを使用する
  - イベントハンドラは純関数で無くてもOK
  - `useEffect` を使用した副作用は最終手段(できるだけコンポーネントが返すJSX内で行う)

## UI をツリーとして理解する

- React DOM
  - 各コンポーネントから生成されるUIツリー
  - コンポーネントの親子関係が構築される

- ノード
  - ツリー構造における1つの要素、コンポーネント等
  - 他の要素との親子関係を持つ(ツリー構造)

- 依存関係ツリー
  - 親コンポーネントがどの子コンポーネントに依存しているか表現する
  - ビルドツールで使用される

## インタラクティビティの追加

- state
  - 時間の結果と共に変化するデータ
  - コンポーネント固有のメモリ
  - `useState` フックでstateを追加できる

- フック
  - コンポーネントにReactの機能を使用させるための関数

- `useState` が返すもの
  - 初期値(initial state)
  - stateを更新するセッター関数

## イベントへの応答

- イベントハンドラ関数
  - イベントに応答する関数
  - 名前は`handle` を先頭に付ける
  - コンポーネント内部で定義する
  - イベント要素で呼び出すのでは無く、関数を渡す
    - `<button onClick={handleClick}>`: OK
    - `<button onClick={handleClick()}>`: NG

- イベントハンドラのprops
  - `on` で始まる
  - キャメルケース

- 子コンポーネントでキャッチしたイベントは親コンポーネントに向かって伝播する
  - `onScroll` 以外のイベント全て

- イベントハンドラの唯一の引数はイベントオブジェクト
  - `e`、`event`

- イベントハンドラは副作用を持ってもOK
  - イベントに応じて描画の変更
  - 入力した値に更新する

## state : コンポーネントのメモリ

- state
  - コンポーネント固有のメモリ
  - 同じコンポーネントを複数描画していても値はローカル
    - 描画コンポーネント毎に独自の値を保持している状態
  - 親コンポーネントが値を変更することはできない

- useStateの2つの機能
  - データ保持: state変数
  - 再レンダリング呼び出し: stateセッター関数
  - 全てのコンポーネントにおいてこの2つのペアで必ず保持されている

- `useState()` はトップレベルで定義する
  - `render()` 内に含めない

## レンダーとコミット

- レンダーのトリガー
  - 初回のレンダリング
  - コンポーネントのstateの更新

- レンダリングの対象
  - 初回: rootコンポーネントの呼び出し
  - 再レンダリング: stateでトリガされたコンポーネント(変更された箇所のみ)

- トリガーからレンダリングまでの流れ
  1. トリガー発生
  2. stateの書き換え
  3. 対象コンポーネントのDOM書き換え
  4. DOMを元にブラウザが再描画

## stateはスナップショットである

- レンダーするとは
  - コンポーネント(関数)を呼び出すこと
  - コンポーネントが返すJSXは呼び出し時のUIのスナップショット
    - props、イベントハンドラ等全てが呼び出し時の状態

## 一覧のstateの更新をキューに入れる

- 複数のstateの更新がある場合はまとめて更新される
  - 更新される対象の数だけ更新される訳ではない

- イベントハンドラの処理が完了したら再レンダリングを行う
  - イベント処理と再レンダリングは並行処理では進まない

## state内のオブジェクトの更新

- ミューダブル
  - 値を書き換え可能なこと

- ミューテーション
  - 値を書き換えること
  - オブジェクトは値の書き換えが可能

- stateの値はミューダブルでも書き換えはNG
  - 読み取り専用として扱うべき
  - 値の更新にはstateセット関数を使用する
    - stateセット関数以外だと再レンダリングされない

- ローカルミューテーション
  - 既存のstateでは無く、新たに作成したオブジェクトに対して値を書き換えること
  - 作成したオブジェクトは参照されていないので問題にならない

- Immer
  - ミューテート型の構文で自動的にコピーを作成してくれるライブラリ
  - Proxyオブジェクトを利用している

- stateの変更がNGの理由
  - state、propsが変化が他の処理のトリガーになっている
  - stateがスナップショットのように扱われるのを前提に機能が設計されている
  - stateの変更を行わない方が使用変更し易い
  - ミューテーションの仕組みに依存しないため実装がシンプルになる

## state内の配列の更新

- 配列をstateとして扱う場合はイミューダブル(書き換え不可)として扱う
  - オブジェクトと同様に元の配列をコピーする
  - `push()`、`pop()`などのミューテーションメソッドの使用はNG

- 配列のstateの変更時に使用するメソッド
  - 追加
    - concat
  - 削除
    - filter、slice
  - 要素置換
    - map

- stateの値で既存のオブジェクトの書き換えはNG
  - 新しく作成したオブジェクトであればOK
  - 書き換えたい場合は元のオブジェクトをコピーした値で更新する

- Immer
  - オブジェクトの書き換え時に自動でコピーを作成してくれる
  - コピーに対してなのでミューテーションメソッドが使える

## state を使って入力に反応する

- UIを更新する2つの方法
  - 命令型: UIの更新を順序立てて記述する
  - 宣言型: UIの更新状態を先に宣言し、更新処理自体はプログラムに任せる

- UIの更新の実装手順
  1. UIを状態別に全て書き出す
  2. UIの更新のトリガーを決める
  3. UIの状態を管理するstateを全て書き出す
  4. 書き出したstateが状態の矛盾が発生しないように不要なstateを削除する
  5. イベントハンドラでstateを更新する

- `e.stopPropagation()` でコンポーネントへの伝播を停止できる

## state構造の選択

- stateの設定時の原則
  - 同時更新するstateは1つにまとめる
  - 矛盾するsteteは作らない
  - 計算できる情報はstateにしない
  - 同じデータが複数のstateにまたがらないようにする
  - ネストの深いstateにしない
  - propsをstateにコピーしない

## コンポーネント間でstateを共有する

- 複数のコンポーネントのstateの同時更新は共通の親でstateで管理する
  - 子コンポーネントには以下を渡す
    - propsとして値
    - state更新用のイベントハンドラ

## stateの保持とリセット

- stateは各コンポーネントが保持しているのでは無く、React自身が保持している

- コンポーネント削除時にstateも削除される
  - 次回描画時はstateはリセットされた状態になる
  - コンポーネントが削除されない限りstateの値は保持し続ける

- 再描画時にstateを保持したい場合はツリー構造が変更前/変更後で変化が無いようにする

- コンポーネント関数の定義の注意点
  - トップレベルで定義
  - コンポーネント内で定義をネストさせない

- 複数の同じコンポーネントでもkeyが異なる場合は別コンポーネントとして認識される
  - 意図しないstateの共有を防止できる

## state ロジックをリデューサに抽出する

- リデューサ関数
  - コンポーネント外部に設置する単一のstate更新用関数
  - 複数のstate更新処理のかたまり
  - `useState` ではなく`useReducer` を使用する
  - stateの更新処理を外部に移動するイメージ
  - 「ここまでのstate」、「アクション」を受け取り「次のstate」を返す

- ディスパッチ
  - 処理の送信
  - 郵便物を送ることでイメージできる
    - アクション:郵便物
    - ディスパッチ: 郵便物を配達する
    - リデューサ―: 郵便局

- アクション
  - ディスパッチに送るオブジェクト
  - オブジェクトに「何が起こったか」を表現する最小限の情報
  - JavaScriptオブジェクト

- リデューサの注意点
  - 副作用を起こす処理はNG
  - オブジェクト、配列をミューテーションせずに更新する(useStateと同じ)
  - 複数のstate更新であっても単一のアクションで表現する

## コンテクストで深くデータを受け渡す

- propsの穴掘り作業
  - props drilling
  - stateのリフトアップと遠くの親まで行う状況
  - 親から子へのpropsの受け渡しが複数の階層を跨いで行われること

- コンテクストとは
  - propsで共有していた情報を特定のコンポーネントに直接渡せる
  - コンテクストを配信しているコンポーネントで囲んだ子コンポーネントはそのコンテクスト(文脈)が適応される
  - 複数の中間コンポーネントをスキップしてpropsを渡すイメージ

  - 異なるコンテクストはお互いを上書きしない

- コンテクストの使い方
  1. 親コンポーネントで`createContext` でコンテクストの作成
  2. 子コンポーネントで`useContext` で作成したコンテクストを呼び出す 
  3. コンテクストを提供するコンポーネントで`コンテクスト名.Provider` で子コンポーネントを囲む(コンテクスト提供)
  4. 子コンポーネントは直近の`コンテクスト名.Provider` の値を使用する

- `createContext` 
  - 唯一の引数はデフォルト値
  - トップレベルで定義する(`useState` 等と同じ)

- コンテクストを使用する前に検討すること
  - propsを渡す方法で実現できないか
  - 子コンポーネントとして抽出し、childrenを渡すことでで実現できないか

## リデューサとコンテクストでスケールアップ

- エントリポイントで管理しているstate、イベントハンドラをコンテクストで管理することが可能
  - 離れた子コンポーネントへ直接state、イベントハンドラを渡せる

## ref で値を参照する

- ref
  - stateと同様にコンポーネントに値を保持できる
  - stateと異なり、値セット時に再レンダーされない
  - `const ref = useRef(初期値)`
  - `ref.current` で現在値にアクセスできる

- refの使用用途
  - 外部システム、APIと連携する場合の再レンダーを必要としない値の保持
  - 描画後のDOM要素を操作する処理

## ref で DOM を操作する

- ReactでDOMを直接操作することは殆どない
  - 自動でDOMを更新するため

- フォーカス、スクロール等は直接DOMを操作する必要がある
  - DOMノードをrefで管理することで可能
    - `<div ref={myRef}`
    
- refで管理したDOMノードに対してブラウザAPIを呼び出すことでDOMを操作できる
  - `ref.current.focus()`

- フック(useXXX)はコンポーネントのトップレベルで呼び出される必要がある

- refコールバック
  - refオブジェクトを返す代わりに関数を渡して実行する
  - 対象のDOMノードが削除されると、コールバックが返したクリーンアップ関数を自動で呼ぶ

```js
<div ref={() => {
    処理;
    return () => {
      クリーンアップ処理;
  }
}>
```

- stateと同様に子コンポーネントにrefを渡すことが可能

- refの動作を変更するには`useImperativeHandle` を使用する

- 任意のタイミングでDOMを更新したい場合は`flushSync()` を使用する

## エフェクトを使って同期を行う

- エフェクト
  - 特定のイベントをトリガーとせずにコンポーネントに副作用を起こさせるもの
  - 画面更新後(コミット後)に処理が実行される
    - 画面更新後まで処理の実行を遅らせる
  - 外部システムとの同期で使用される

エフェクトの書き方

1. エフェクトの宣言
  - コンポーネントのトップレベルで`useEffect`
2. エフェクトの依存配列の指定
  - エフェクトのトリガーになる値を配列で指定する
  - 指定して値に変化があった場合のみエフェクトを実行する
  - `[]` を指定した場合はマウント時のみにエフェクトが実行される
3. 必要に応じてクリーンアップを追加
  - `useEffect` 内でクリーンアップ関数をreturnする

- 開発環境(Strict Mode)では自動でエフェクトは2回実行される
  - バグを発見するため

## そのエフェクトは不要かも

- 不要なエフェクト
  - 描画で使用する値の副作用
    - state、propsが変更されると自動で再実行される
  - ユーザーの操作をトリガーとする処理
    - イベントハンドラで操作可能

- `useMemo()`
  - 重たい処理をキャッシュするためのフック
  - 引数の値が変更になった時のみ処理を行う

- `console.time()` で処理を囲むことで処理の時間計測が可能

## リアクティブなエフェクトのライフサイクル

- コンポーネントのライフサイクル
  - マウント
  - 更新
  - アンマウント

- エフェクトのライフサイクル
  - 同期の開始
  - 同期の停止

- 1つのエフェクトは1つの独立した処理のみを記述する
- エフェクトの依存配列にはリアクティブ値のみ指定する
  - リアクティブ値以外は変化しないので指定する意味が無い
- エフェクトの依存配列に`[]` を指定した場合はマウント/アンマウント時にエフェクトを実行する

- コンポーネント内の全ての値はリアクティブ値
  - props
  - state
  - コンポーネント内の変数

- `ref.current` はミューダブルな値
  - エフェクトの依存配列には含められない
  - ミューダブルな値をエフェクトの依存配列に指定してもトリガーにならない

- エフェクトの依存配列を選ぶことはできない
  - エフェクトで使用するリアクティブ値を全て含める必要がある
  - リンターエラーが発生する

## エフェクトからイベントを分離する

- イベントハンドラ
  - ユーザーの操作をトリガーにした処理で使用する
  - 値の変化に反応せずに処理を行う

- エフェクト
  - ユーザーの操作に関係無く、画面が表示されたら行いたい処理で使用する
  - リアクティブ値の変化に反応して処理を行う

- `useEffectEvent`
  - エフェクト内で非リアクティブ値なロジックを分離できる
  - エフェクト内でイベントハンドラのような動作ができる
  - 呼び出し側のエフェクトで依存配列には指定しない
    - エフェクトイベントはリアクティブ値では無いため
  - エフェクト内で呼び出されるイベントハンドラのイメージ

最新のAPIなのでスキップ

## エフェクトから依存値を取り除く

- エフェクトの依存配列にリアクティブ値を指定することで、リアクティブの変更に反応してエフェクトが行われることが保証される

- エフェクトの依存配列に指定するリアクティブ値
  - 定義したコンポーネント内で定義した関数、変数
  - コンポーネントに渡ってきたprops

- エフェクト内の依存配列はエフェクトで使用するリアクティブ値のリスト
- エフェクトの依存配列に`[]` を渡すことはリンターの警告を無視させていることになる
- エフェクト内で複数の処理が依存関係を持つ場合は別々のエフェクトに分割する

## カスタムフックでロジックを再利用する

- カスタムフック
  - 内部でフックを使用する独自ロジックのフック
  - フック名は`use` から始める
  - コンポーネントといっしょに再レンダーされる
    - 最新のprops、stateを受け取る
